import re
import os
import glob
import io
import openai
from base64 import b64decode
from datetime import datetime
from PIL import Image, ImageDraw, ImageFont
import json

def send_and_receive_message(text_model: str, userMessage: str, conversationTemp: list, temperature: int = 0.5) -> str:
    """fetches openai text respose

    Args:
      text_model (string): model name used for openai (eg: "gpt-4", "gpt-3.5-turbo", etc)
      userMessage (string): user prompt to specify meme content
      conversationTemp (list): model finetuning confing generated by "construct_system_prompt"
      temperature (int): TODO

    Returns:
      AI Generated string to userMessage based on conversation and temperature
    """

    # Prepare to send request along with context by appending user message to previous conversation
    conversationTemp.append({"role": "user", "content": userMessage})

    print("Sending request to write meme...")
    chatResponse = openai.ChatCompletion.create(
        model=text_model,
        messages=conversationTemp,
        temperature=temperature
        )

    chatResponseMessage = chatResponse.choices[0].message.content

    return chatResponseMessage

def generate_template(image_path: str, top_text: str, metadata: dict, fontFile: str, filePath :str = None, min_scale: float = 0.05, buffer_scale: float = 0.03, font_scale: float = 1) -> Image:
    """Constructs Meme From image, and text data

    Args:
        image_path (string): path to image location
        top_text (string):  text to be printed on the meme
        metadata (dict): dictionary containing text co-ordinates (x1, y1, x2, y2)
        fontFile (string): path to font file
        filePath (string): path for meme to be saved
        min_scale (float): factor to warp text
        buffer_scale (float): factor for boundry buffer
        font_scale (float): factor default font size

    Returns:
        Meme with Text as a PIL Image
    """
    print("Creating meme image...")

    x1 = metadata["x1"]
    y1 = metadata["y1"]
    x2 = metadata["x2"]
    y2 = metadata["y2"]

    image = Image.open(image_path)

    # Calculate buffer size based on buffer_scale
    buffer_size = int(buffer_scale * image.width)

    # Get a drawing context
    d = ImageDraw.Draw(image)

    # Split the text into words
    words = top_text.split()

    # Initialize the font size and wrapped text
    font_size = int(font_scale * image.width)
    fnt = ImageFont.truetype(fontFile, font_size)
    wrapped_text = top_text


    # Try to fit the text on a single line by reducing the font size
    while d.textbbox((x1, y1), wrapped_text, font=fnt)[2] > (x2-x1) - 2 * buffer_size:
        font_size *= 0.9  # Reduce the font size by 10%

        if font_size < min_scale * (x2-x1):
            # If the font size is less than the minimum scale, wrap the text
            lines = [words[0]]
            for word in words[1:]:
                new_line = (lines[-1] + ' ' + word).rstrip()
                if d.textbbox((x1,y1), new_line, font=fnt)[2] > (x2-x1) - 2 * buffer_size:
                    lines.append(word)
                else:
                    lines[-1] = new_line
            wrapped_text = '\n'.join(lines)
            break
        fnt = ImageFont.truetype(fontFile, int(font_size))

    # Calculate the bounding box of the text
    textbbox_val = d.multiline_textbbox((x1,y1), wrapped_text, font=fnt)

    # Create a white band for the top text, with a buffer equal to 10% of the font size
    band_height = textbbox_val[3] - textbbox_val[1] + int(font_size * 0.1) + 2 * buffer_size
    band = Image.new('RGBA', (x2-x1, band_height), (255,255,255,255))

    # Draw the text on the white band
    d = ImageDraw.Draw(band)

    # The midpoint of the width and height of the bounding box
    text_x = band.width // 2
    text_y = band.height // 2

    d.multiline_text((text_x, text_y), wrapped_text, font=fnt, fill=(0,0,0,255), anchor="mm", align="center")

    image.paste(band, (x1,y1))

    return image

def construct_system_prompt(basic_instructions: str = "You will create funny memes.",  genre: str = "dark humor") -> str:
    """Gets Finetuning text for openai meme generation
    
    Args:
      basic_instructions (string): Generation of funny memes specification
      genre (string): finetune to a particular genre of memes

    Returns:
      String giving fintuning intruction to openai
    """
    format_instructions = f'You are a meme generator with the following formatting instructions. Each meme will consist of text that will appear at the top, and an image to go along with it. The user will send you a message with a general theme or concept on which you will base the meme. The user may choose to send you a text saying something like "anything" or "whatever you want", or even no text at all, which you should not take literally, but take to mean they wish for you to come up with something yourself.  The memes don\'t necessarily need to start with "when", but they can. In any case, you will respond with two things: First, the text of the meme that will be displayed in the final meme. Second, some text that will be used as an image prompt for an AI image generator to generate an image to also be used as part of the meme. You must respond only in the format as described next, because your response will be parsed, so it is important it conforms to the format. The first line of your response should be: "Meme Text: " followed by the meme text. The second line of your response should be: "Image Prompt: " followed by the image prompt text.  --- Now here are additional instructions... '
    basicInstructionAppend = f'Next are instructions for the overall approach you should take to creating the memes. Interpret as best as possible: {basic_instructions} | '
    MemeInstructions = f"Make it funny to appeal to a gen z audience. IT NEEDS TO FIT {genre} genre."
    systemPrompt = format_instructions + basicInstructionAppend  + MemeInstructions

    return systemPrompt

def parse_meme(message: dict) -> dict:
    """ Parses openai message to find meme text

    Args:
        message (dict): openai message output from content

    Returns:
        dictionary containting meme text and image query for dall-e
    """
    # The regex pattern to match
    pattern = r'Meme Text: (\"(.*?)\"|(.*?))\n*\s*Image Prompt: (.*?)$'

    match = re.search(pattern, message, re.DOTALL)

    if match:
        # If meme text is enclosed in quotes it will be in group 2, otherwise, it will be in group 3.
        meme_text = match.group(2) if match.group(2) is not None else match.group(3)

        return {
            "meme_text": meme_text,
            "image_prompt": match.group(4)
        }
    else:
        return None

def generate_meme(text_model: str, userEnteredPrompt: str, conversation: list, template: str, temperature: int, fontFile: str = "Fonts/arial.ttf") -> dict:
    """Generates Meme using generative AI

    Args:
      text_model (string): model name used for openai (eg: "gpt-4", "gpt-3.5-turbo", etc)
      userEnteredPrompt (string): user prompt to specify meme content
      conversation(list): model finetuning confing generated by "construct_system_prompt"
      template (string): meme template name
      temperature (int): TODO
      fontFile (string): path to font file

    Returns:
      dictionary containing meme text, meme image description, meme path, meme, meme file name
    """

    f = open("Templates/configs/metadata.json")
    db = json.load(f)

    if template not in list(db["map"].keys()):
        f.close()
        raise FileNotFoundError(f"{template} does not exist")
    
    template_id = db["map"][template]
    template_data = db["memes"][template_id]
    text_id = template_data["text_id"]

    SpecificPrompt = userEnteredPrompt + ". maximum number of sentences should be: " + db["text_id"][text_id]["sentences"] + " and should fit the " + template + "meme template"

    # Send request to chat bot to generate meme text and image prompt
    chatResponse = send_and_receive_message(text_model, SpecificPrompt, conversation, temperature)

    # Take chat message and convert to dictionary with meme_text and image_prompt
    memeDict = parse_meme(chatResponse)
    meme_text = memeDict['meme_text']

    # Print the meme text and image prompt
    print("\n   Meme Text:  " + meme_text)
    print("   Image Prompt:  " + template)

    # filePath, fileName = set_file_path(base_file_name, output_folder) # For later implemetation
    meme = generate_template(image_path=template_data["path"], top_text=meme_text, metadata=template_data, fontFile=fontFile)

    # absoluteFilePath = os.path.abspath(filePath)
    absoluteFilePath = "success"
    fileName = template

    return {"meme_text": meme_text, "image_prompt": template, "file_path": absoluteFilePath, "meme": meme, "file_name": fileName}



