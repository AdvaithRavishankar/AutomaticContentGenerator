import re
import os
import glob
import io
import openai
from base64 import b64decode
from datetime import datetime
from PIL import Image, ImageDraw, ImageFont

def send_and_receive_message(text_model: str, userMessage: str, conversationTemp: list, temperature: int = 0.5) -> str:
    """fetches openai text respose

    Args:
      text_model (string): model name used for openai (eg: "gpt-4", "gpt-3.5-turbo", etc)
      userMessage (string): user prompt to specify meme content
      conversationTemp (list): model finetuning confing generated by "construct_system_prompt"
      temperature (int): TODO

    Returns:
      AI Generated string to userMessage based on conversation and temperature
    """

    # Prepare to send request along with context by appending user message to previous conversation
    conversationTemp.append({"role": "user", "content": userMessage})

    print("Sending request to write meme...")
    chatResponse = openai.ChatCompletion.create(
        model=text_model,
        messages=conversationTemp,
        temperature=temperature
        )

    chatResponseMessage = chatResponse.choices[0].message.content

    return chatResponseMessage

def parse_meme(message: dict) -> dict:
    """ Parses openai message to find meme text

    Args:
        message (dict): openai message output from content

    Returns:
        dictionary containting meme text and image query for dall-e
    """
    # The regex pattern to match
    pattern = r'Meme Text: (\"(.*?)\"|(.*?))\n*\s*Image Prompt: (.*?)$'

    match = re.search(pattern, message, re.DOTALL)

    if match:
        # If meme text is enclosed in quotes it will be in group 2, otherwise, it will be in group 3.
        meme_text = match.group(2) if match.group(2) is not None else match.group(3)

        return {
            "meme_text": meme_text,
            "image_prompt": match.group(4)
        }
    else:
        return None

def image_generation_request(image_prompt: str) -> io.BytesIO:
    """Creates Image Using Dall-e
    
    Args:
        image_prompt (string): image prompt used to generate image in dall-e
    
    Returns:
        Virtual Meme File as an io.BytesIO() class 
    """

    openai_response = openai.Image.create(prompt=image_prompt, n=1, size="512x512", response_format="b64_json")
    # Convert image data to virtual file
    image_data = b64decode(openai_response["data"][0]["b64_json"])
    virtual_image_file = io.BytesIO()
    # Write the image data to the virtual file
    virtual_image_file.write(image_data)

    return virtual_image_file

def set_file_path(baseName, outputFolder):
    """Gets file path

    TODO

    """

    def get_next_counter():
        # Check existing files in the directory
        existing_files = glob.glob(os.path.join(outputFolder, baseName + "_" + timestamp + "_*.png"))

        # Get the highest existing counter, if any
        max_counter = 0
        for file in existing_files:
            try:
                counter = int(os.path.basename(file).split('_')[-1].split('.')[0])
                max_counter = max(max_counter, counter)
            except ValueError:
                pass
        # Return the next available counter
        return max_counter + 1

    # Generate a timestamp string to append to the file name
    timestamp = datetime.now().strftime("%Y-%m-%d-%H-%M")

    # If the output folder does not exist, create it
    if not os.path.exists(outputFolder):
        os.makedirs(outputFolder)

    # Get the next counter number
    file_counter = get_next_counter()

    # Set the file name
    fileName = baseName + "_" + timestamp + "_" + str(file_counter) + ".png"
    filePath = os.path.join(outputFolder, fileName)

    return filePath, fileName


def create_meme(image_path: str, top_text: str, filePath: str, fontFile: str, min_scale: float = 0.05, buffer_scale: float = 0.03, font_scale: float = 1) -> Image:
    """Constructs Meme From image, and text data

    Args:
        image_path (string): path to image location
        top_text (string):  text to be printed on the meme
        metadata (dict): dictionary containing text co-ordinates (x1, y1, x2, y2)
        fontFile (string): path to font file
        filePath (string): path for meme to be saved
        min_scale (float): factor to warp text
        buffer_scale (float): factor for boundry buffer
        font_scale (float): factor default font size

    Returns:
        Meme with Text as a PIL Image
    """
    print("Creating meme image...")

    # Load the image. Can be a path or a file-like object such as IO.BytesIO virtual file
    image = Image.open(image_path)

    # Calculate buffer size based on buffer_scale
    buffer_size = int(buffer_scale * image.width)

    # Get a drawing context
    d = ImageDraw.Draw(image)

    # Split the text into words
    words = top_text.split()

    # Initialize the font size and wrapped text
    font_size = int(font_scale * image.width)
    fnt = ImageFont.truetype(fontFile, font_size)
    wrapped_text = top_text

    # Try to fit the text on a single line by reducing the font size
    while d.textbbox((0,0), wrapped_text, font=fnt)[2] > image.width - 2 * buffer_size:
        font_size *= 0.9  # Reduce the font size by 10%
        if font_size < min_scale * image.width:
            # If the font size is less than the minimum scale, wrap the text
            lines = [words[0]]
            for word in words[1:]:
                new_line = (lines[-1] + ' ' + word).rstrip()
                if d.textbbox((0,0), new_line, font=fnt)[2] > image.width - 2 * buffer_size:
                    lines.append(word)
                else:
                    lines[-1] = new_line
            wrapped_text = '\n'.join(lines)
            break
        fnt = ImageFont.truetype(fontFile, int(font_size))

    # Calculate the bounding box of the text
    textbbox_val = d.multiline_textbbox((0,0), wrapped_text, font=fnt)

    # Create a white band for the top text, with a buffer equal to 10% of the font size
    band_height = textbbox_val[3] - textbbox_val[1] + int(font_size * 0.1) + 2 * buffer_size
    band = Image.new('RGBA', (image.width, band_height), (255,255,255,255))

    # Draw the text on the white band
    d = ImageDraw.Draw(band)

    # The midpoint of the width and height of the bounding box
    text_x = band.width // 2
    text_y = band.height // 2

    d.multiline_text((text_x, text_y), wrapped_text, font=fnt, fill=(0,0,0,255), anchor="mm", align="center")

    # Create a new image and paste the band and original image onto it
    new_img = Image.new('RGBA', (image.width, image.height + band_height))
    new_img.paste(band, (0,0))
    new_img.paste(image, (0, band_height))

    return new_img

# Construct the system prompt for the chat bot
def construct_system_prompt(basic_instructions: str = "You will create funny memes.", image_special_instructions: str = "The images should be photographic.", genre: str = "dark humor") -> str:
    """Gets Finetuning text for openai meme generation
    
    Args:
      basic_instructions (string): Generation of funny memes specification
      image_special_instruction (string): specifing image correspondence for text
      genre (string): finetune to a particular genre of memes

    Returns:
      String giving fintuning intruction to openai
    """
    format_instructions = f'You are a meme generator with the following formatting instructions. Each meme will consist of text that will appear at the top, and an image to go along with it. The user will send you a message with a general theme or concept on which you will base the meme. The user may choose to send you a text saying something like "anything" or "whatever you want", or even no text at all, which you should not take literally, but take to mean they wish for you to come up with something yourself.  The memes don\'t necessarily need to start with "when", but they can. In any case, you will respond with two things: First, the text of the meme that will be displayed in the final meme. Second, some text that will be used as an image prompt for an AI image generator to generate an image to also be used as part of the meme. You must respond only in the format as described next, because your response will be parsed, so it is important it conforms to the format. The first line of your response should be: "Meme Text: " followed by the meme text. The second line of your response should be: "Image Prompt: " followed by the image prompt text.  --- Now here are additional instructions... '
    basicInstructionAppend = f'Next are instructions for the overall approach you should take to creating the memes. Interpret as best as possible: {basic_instructions} | '
    specialInstructionsAppend = f'Next are any special instructions for the image prompt. For example, if the instructions are "the images should be photographic style", your prompt may append ", photograph" at the end, or begin with "photograph of". It does not have to literally match the instruction but interpret as best as possible: {image_special_instructions}.'
    MemeInstructions = f"Make it funny to appeal to a gen z audience. It needs to include {genre}."
    systemPrompt = format_instructions + basicInstructionAppend + specialInstructionsAppend + MemeInstructions

    return systemPrompt

def generate_meme(text_model: str, userEnteredPrompt: str, conversation: list, temperature: int, fontFile: str = "Fonts/arial.ttf") -> dict:
    """Generates Meme using generative AI

    Args:
      text_model (string): model name used for openai (eg: "gpt-4", "gpt-3.5-turbo", etc)
      userEnteredPrompt (string): user prompt to specify meme content
      conversation(list): model finetuning confing generated by "construct_system_prompt"
      temperature (int): TODO
      fontFile (string): path to font file

    Returns:
      dictionary containing meme text, meme image description, meme path, meme, meme file name
    """

    # Send request to chat bot to generate meme text and image prompt
    chatResponse = send_and_receive_message(text_model, userEnteredPrompt, conversation, temperature)

    # Take chat message and convert to dictionary with meme_text and image_prompt
    memeDict = parse_meme(chatResponse)
    image_prompt = memeDict['image_prompt']
    meme_text = memeDict['meme_text']

    # Print the meme text and image prompt
    print("\n   Meme Text:  " + meme_text)
    print("   Image Prompt:  " + image_prompt)

    # Send image prompt to image generator and get image back (Using DALLÂ·E API)
    print("\nSending image creation request...")
    virtual_image_file = image_generation_request(image_prompt)

    base_file_name = "test.png"
    output_folder = "memes"

    # Combine the meme text and image into a meme
    filePath, fileName = set_file_path(base_file_name, output_folder)
    meme = create_meme(virtual_image_file, meme_text, filePath, fontFile=fontFile)

    absoluteFilePath = os.path.abspath(filePath)

    return {"meme_text": meme_text, "image_prompt": image_prompt, "file_path": absoluteFilePath, "meme": meme, "file_name": fileName}